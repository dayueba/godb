## 一个用go写的简单的关系型数据库

资料：https://build-your-own.org/database/

1. b+ tree
2. 在写时复制 B+tree KV 上具有并发事务的关系数据库。
3. 类sql查询

为什么需要数据库？
1. 仅使用文件是不够的，当写文件时程序崩溃了怎么办？停电了怎么办？
   1. 文件会丢失最后一次写入吗？
   2. 还是最终只写了一半？
   3. 还是最终处于更加损坏的状态？
   4. 任何情况都有可能发生，写文件只在最好的情况有效

   

fsync：向文件写入数据不是一个同步过程；存在多级缓存（操作系统页面缓存和设备上缓存）。fsync 系统调用要求立即刷新所有写入的数据，并阻塞直到完成。
在数据被 fsync 之前，数据库不会响应客户端，因此客户端可以相信数据在响应成功后已被持久化。

rename + fsync 实现'耐久性'的数据库
1. 将整个更新后的数据集写入一个新文件。
2. 在新文件上调用 fsync。
3. 通过将新文件重命名为旧文件来覆盖旧文件，文件系统保证这将是原子的。（速度非常快）

这种方法只适用于不经常更新的微小数据，而且除了效率低之外，还有其他缺陷。因此，我们更应该使用数据库。


如何确保 append 日志 正确性

解决办法就是checksum：add a checksum to each log entry. If the checksum is wrong, the update did not happen, making log updates atomic (w.r.t. both readers and durability).

这种情况是指在 fsync 成功之前发生的不完整写入（用 DB 术语来说就是撕裂写入）。校验和也可以在同步后检测到其他形式的损坏，但这不是数据库可以恢复的。

b+ tree

更新B+树时要注意
1. 所有叶节点高度相同。
2. 节点大小以常数为界。
3. 节点不为空 。

为了简化实现
1. 叶节点和内部节点使用相同的格式。这样会浪费一些空间：叶节点不需要指针，内部节点不需要值。
2. n 个分支的内部节点包含 n 个键，每个键都是从相应子树的最小键复制而来。不过，n 个分支只需要 n - 1 个键，这在其他 B 树介绍中也会提到。额外的键使可视化更加容易。
3. 我们将节点大小设置为 4K，这是操作系统典型的页面大小。但是，键和值可以任意大，超过单个节点的大小。应该有办法在节点外存储大的 KV，或者使节点大小可变。这个问题可以解决，但不是根本问题。因此，我们可以跳过这个问题，限制 KV 的大小，使其始终适合存放在节点内。

持久性
1. 崩溃恢复：这包括数据库进程崩溃、操作系统崩溃和电源故障。数据库必须在重启后处于可用状态。
2. 持久性：数据库成功响应后，即使发生崩溃，相关数据也能保证持久。换句话说，持久性发生在响应客户端之前。